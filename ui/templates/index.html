<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SelfObserver // MONITOR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-cyan: #00f3ff;
            --neon-purple: #bc13fe;
            --neon-green: #0aff0a;
            --bg-dark: #050b14;
            --panel-bg: rgba(16, 23, 41, 0.7);
        }

        body {
            background-color: var(--bg-dark);
            color: #e2e8f0;
            font-family: 'JetBrains Mono', monospace;
            overflow-x: hidden;
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(20, 30, 50, 0.5) 0%, transparent 50%),
                linear-gradient(0deg, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2) 50%),
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 100% 100%, 4px 4px, 40px 40px, 40px 40px;
        }

        /* Glassmorphism Panel */
        .tech-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        /* Scanline Effect */
        .tech-panel::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        /* Corner Accents */
        .corner-accent::before, .corner-accent::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            border: 1px solid var(--neon-cyan);
            transition: all 0.3s ease;
        }
        .corner-accent::before { top: -1px; left: -1px; border-right: none; border-bottom: none; }
        .corner-accent::after { bottom: -1px; right: -1px; border-left: none; border-top: none; }
        
        .corner-accent:hover::before, .corner-accent:hover::after {
            width: 100%;
            height: 100%;
            border-color: var(--neon-purple);
            opacity: 0.5;
        }

        /* Animations */
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .animate-blink { animation: blink 2s infinite; }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 5px var(--neon-cyan); }
            50% { box-shadow: 0 0 20px var(--neon-cyan), 0 0 10px var(--neon-purple); }
            100% { box-shadow: 0 0 5px var(--neon-cyan); }
        }
        .active-status { animation: pulse-glow 3s infinite; }

        @keyframes slideIn {
            from { transform: translateX(-10px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .log-entry { animation: slideIn 0.3s ease-out forwards; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--neon-cyan); }

        /* Typography Utilities */
        .text-neon-cyan { color: var(--neon-cyan); text-shadow: 0 0 5px rgba(0, 243, 255, 0.5); }
        .text-neon-purple { color: var(--neon-purple); text-shadow: 0 0 5px rgba(188, 19, 254, 0.5); }
        .text-neon-green { color: var(--neon-green); text-shadow: 0 0 5px rgba(10, 255, 10, 0.5); }
        
        .glitch-hover:hover {
            animation: blink 0.1s infinite;
            color: var(--neon-cyan);
        }

        #log-container {
            mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
        }
    </style>
</head>
<body class="h-screen flex flex-col p-4 gap-4">

    <!-- Header -->
    <header class="flex justify-between items-center tech-panel p-4 rounded-lg corner-accent shrink-0">
        <div class="flex items-center gap-4">
            <div class="w-3 h-3 rounded-full bg-green-500 active-status"></div>
            <div>
                <h1 class="text-2xl font-bold tracking-wider text-white">SELF<span class="text-neon-cyan">OBSERVER</span>_V2</h1>
                <p class="text-xs text-slate-400 uppercase tracking-[0.2em]">Local Behavior Telemetry System</p>
            </div>
        </div>
        <div class="flex gap-4 text-xs font-bold">
            <div class="text-right">
                <div class="text-slate-500">SYSTEM TIME</div>
                <div id="clock" class="text-neon-cyan text-lg">00:00:00</div>
            </div>
            <div class="text-right border-l border-slate-700 pl-4">
                <div class="text-slate-500">UPTIME</div>
                <div class="text-white">04:20:59</div>
            </div>
        </div>
    </header>

    <!-- Main Grid -->
    <main class="flex-1 grid grid-cols-12 gap-4 min-h-0">
        
        <!-- Left Column: Stats & Logs -->
        <div class="col-span-12 lg:col-span-8 flex flex-col gap-4 min-h-0">
            
            <!-- Cards Row -->
            <div class="grid grid-cols-3 gap-4 shrink-0 h-32">
                <!-- Mode Card -->
                <div class="tech-panel rounded-lg p-4 flex flex-col justify-between corner-accent hover:border-cyan-500/50 transition-colors group">
                    <div class="flex justify-between items-start">
                        <span class="text-xs text-slate-400 uppercase tracking-widest">Current Mode</span>
                        <i class="text-neon-purple opacity-50 group-hover:opacity-100 transition-opacity">●</i>
                    </div>
                    <div id="stat-mode" class="text-3xl font-bold text-white truncate glitch-hover">Loading...</div>
                    <div class="w-full bg-slate-800 h-1 mt-2 overflow-hidden">
                        <div class="h-full bg-neon-purple w-2/3 animate-pulse"></div>
                    </div>
                </div>

                <!-- App Card -->
                <div class="tech-panel rounded-lg p-4 flex flex-col justify-between corner-accent hover:border-cyan-500/50 transition-colors">
                    <div class="text-xs text-slate-400 uppercase tracking-widest">Active Process</div>
                    <div id="stat-exe" class="text-xl font-bold text-neon-cyan truncate">...</div>
                    <div id="stat-title" class="text-xs text-slate-400 truncate mt-1 border-t border-slate-700 pt-1">Waiting for telemetry...</div>
                </div>

                <!-- Confidence Card -->
                <div class="tech-panel rounded-lg p-4 flex flex-col justify-between corner-accent hover:border-cyan-500/50 transition-colors">
                    <div class="text-xs text-slate-400 uppercase tracking-widest">Model Confidence</div>
                    <div class="flex items-end gap-2">
                        <div id="stat-conf" class="text-4xl font-bold text-neon-green">0.0</div>
                        <span class="text-sm text-slate-500 mb-1">%</span>
                    </div>
                    <!-- Fake mini graph -->
                    <div class="flex items-end gap-1 h-4 mt-1 opacity-50">
                        <div class="w-1 bg-green-500 h-2/3"></div>
                        <div class="w-1 bg-green-500 h-full"></div>
                        <div class="w-1 bg-green-500 h-1/2"></div>
                        <div class="w-1 bg-green-500 h-3/4"></div>
                        <div class="w-1 bg-green-500 h-full"></div>
                    </div>
                </div>
            </div>

            <!-- Timeline Chart -->
            <div class="tech-panel rounded-lg p-4 flex-1 corner-accent relative flex flex-col">
                <div class="flex justify-between mb-2">
                    <h2 class="text-sm font-bold text-slate-300 uppercase tracking-widest">Activity Timeline</h2>
                    <div class="flex gap-2">
                        <button onclick="setTheme('cyber')" class="px-2 py-0.5 text-xs border border-cyan-500/30 text-cyan-500 hover:bg-cyan-500/10 transition">CYBER</button>
                        <button onclick="setTheme('glow')" class="px-2 py-0.5 text-xs border border-purple-500/30 text-purple-500 hover:bg-purple-500/10 transition">GLOW</button>
                    </div>
                </div>
                <div class="relative w-full flex-1 min-h-0">
                    <canvas id="lineChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Right Column: Pie & Logs -->
        <div class="col-span-12 lg:col-span-4 flex flex-col gap-4 min-h-0">
            
            <!-- Distribution Chart -->
            <div class="tech-panel rounded-lg p-4 h-64 corner-accent flex flex-col">
                <h2 class="text-sm font-bold text-slate-300 uppercase tracking-widest mb-2">Distribution (Day)</h2>
                <div class="relative w-full flex-1 min-h-0 flex items-center justify-center">
                    <canvas id="pieChart"></canvas>
                </div>
            </div>

            <!-- Live Logs -->
            <div class="tech-panel rounded-lg p-4 flex-1 corner-accent flex flex-col min-h-0">
                <div class="flex justify-between items-center mb-2 border-b border-slate-700 pb-2">
                    <h2 class="text-sm font-bold text-slate-300 uppercase tracking-widest">Event Stream</h2>
                    <span class="text-[10px] text-green-500 animate-blink">● LIVE</span>
                </div>
                <div id="log-container" class="flex-1 overflow-y-auto font-mono text-xs space-y-1 pr-2">
                    <table class="w-full text-left border-collapse">
                        <tbody id="log-body">
                            <!-- Logs injected here -->
                        </tbody>
                    </table>
                </div>
            </div>

        </div>
    </main>

    <script>
        // CONFIGURATION
        const DEMO_MODE = false; // Set to TRUE to use mock data
        
        // --- THEME & UTILS ---
        let pieChart = null;
        let lineChart = null;
        let CURRENT_THEME = localStorage.getItem("line_theme") || "cyber";

        const DYNAMIC_COLOR_MAP = {
            coding: "#00f3ff", // Cyan
            browsing: "#bc13fe", // Purple
            gaming: "#ff0055", // Red/Pink
            chatting: "#0aff0a", // Green
            video: "#ffcc00", // Yellow
            reading: "#56E0E0",
            writing: "#F97316",
            ai_chat: "#10B981",
            idle: "#334155",
            unknown: "#94a3b8"
        };

        const FALLBACK_PALETTE = [
            "#ef4444", "#22c55e", "#3b82f6", "#f59e0b", "#14b8a6", "#a855f7"
        ];

        function formatMinutesFriendly(minutes) {
            const m = minutes || 0;
            if (m >= 60) return `${(m / 60).toFixed(1)}h`;
            return `${m.toFixed(0)}m`;
        }

        function dynamicColor(mode) {
            const key = mode?.toLowerCase?.();
            if (key && DYNAMIC_COLOR_MAP[key]) return DYNAMIC_COLOR_MAP[key];
            const hash = [...(key || 'u')].reduce((acc, ch) => acc + ch.charCodeAt(0), 0);
            return FALLBACK_PALETTE[hash % FALLBACK_PALETTE.length];
        }

        // --- CHART STYLES ---
        function themeStyle(mode, ctx) {
            const color = dynamicColor(mode);
            
            // Fix: Create gradient directly instead of returning a function
            // This prevents variable shadowing issues in Chart.js callbacks
            let gradient;
            try {
                gradient = ctx.createLinearGradient(0, 0, 0, 400);
                gradient.addColorStop(0, color + "44"); // 44 = low opacity hex
                gradient.addColorStop(1, color + "00");
            } catch (e) {
                // Fallback if ctx is invalid
                gradient = color + "22";
            }

            return {
                borderWidth: 2,
                tension: 0.4,
                fill: true,
                backgroundColor: gradient,
                borderColor: color,
                pointRadius: 0,
                pointHoverRadius: 6,
                pointBackgroundColor: "#fff",
            };
        }

        function setTheme(t) {
            CURRENT_THEME = t;
            localStorage.setItem("line_theme", t);
            if(lineChart) lineChart.update();
        }

        // --- UPDATERS ---

        async function fetchData(endpoint) {
            if (DEMO_MODE) return getMockData(endpoint);
            try {
                const res = await fetch(endpoint);
                return await res.json();
            } catch (e) {
                console.error("API Error", e);
                return endpoint.includes("latest") ? [] : {};
            }
        }

        async function updateLogs() {
            const data = await fetchData("/api/latest");
            if (!data.length) return;

            const latest = data[data.length - 1];
            
            // Update Cards
            const modeEl = document.getElementById("stat-mode");
            if(modeEl) {
                modeEl.innerText = latest.mode;
                modeEl.style.color = dynamicColor(latest.mode);
            }
            
            const exeEl = document.getElementById("stat-exe");
            if(exeEl) exeEl.innerText = latest.exe;

            const titleEl = document.getElementById("stat-title");
            if(titleEl) titleEl.innerText = latest.title;
            
            // Animate Confidence Number
            const confEl = document.getElementById("stat-conf");
            if(confEl) {
                const targetConf = ((latest.confidence || 0) * 100).toFixed(1);
                if (confEl.innerText !== targetConf) {
                    confEl.innerText = targetConf;
                    confEl.className = `text-4xl font-bold ${(latest.confidence || 0) > 0.8 ? 'text-neon-green' : 'text-yellow-500'}`;
                }
            }

            // Update Table
            const tbody = document.getElementById("log-body");
            if(tbody) {
                tbody.innerHTML = "";
                [...data].reverse().forEach((d, i) => {
                    const color = dynamicColor(d.mode);
                    const row = `
                    <tr class="border-b border-slate-800 hover:bg-white/5 transition-colors log-entry" style="animation-delay: ${i * 0.05}s">
                        <td class="py-2 pr-2 text-slate-500 text-[10px] w-16 font-mono">${(d.ts || '').split(' ')[1] || d.ts}</td>
                        <td class="py-2 pr-2 font-bold" style="color:${color}">${d.mode}</td>
                        <td class="py-2 text-slate-400 truncate max-w-[150px]" title="${d.title}">
                            <span class="text-white/60">[${d.exe}]</span> ${d.title}
                        </td>
                    </tr>`;
                    tbody.innerHTML += row;
                });
            }
        }

        async function updatePie() {
            const data = await fetchData("/api/stats/day");
            let labels = Object.keys(data);
            let values = Object.values(data).map(v => v / 60);

            if (!labels.length) { labels = ["No Data"]; values = [1]; }

            const colors = labels.map(l => dynamicColor(l));
            const canvas = document.getElementById("pieChart");
            const ctx = canvas.getContext("2d");

            // Fix: Check if chart exists on this canvas and destroy it to avoid "Canvas is already in use"
            const existingChart = Chart.getChart(canvas);
            
            if (!pieChart || !existingChart) {
                if(existingChart) existingChart.destroy(); // Double safety
                
                pieChart = new Chart(ctx, {
                    type: "doughnut",
                    data: {
                        labels: labels,
                        datasets: [{
                            data: values,
                            backgroundColor: colors,
                            borderColor: "#0f172a", // Match bg
                            borderWidth: 2,
                            hoverOffset: 10
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '70%',
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(15, 23, 42, 0.9)',
                                titleColor: '#fff',
                                bodyColor: '#ccc',
                                borderColor: 'rgba(255,255,255,0.1)',
                                borderWidth: 1,
                                padding: 10,
                                callbacks: {
                                    label: function(context) {
                                        return ` ${context.label}: ${formatMinutesFriendly(context.parsed)}`;
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                pieChart.data.labels = labels;
                pieChart.data.datasets[0].data = values;
                pieChart.data.datasets[0].backgroundColor = colors;
                pieChart.update();
            }
        }

        async function updateLine() {
            const data = await fetchData("/api/stats/day");
            
            // FAKE TIME SERIES GENERATION FOR VISUALS
            const labels = ["09:00", "10:00", "11:00", "12:00", "13:00", "14:00"];
            const modes = Object.keys(data).slice(0, 3); // Top 3 modes
            
            const canvas = document.getElementById("lineChart");
            if(!canvas) return;
            const ctx = canvas.getContext("2d");

            // Fix: Clean up existing chart instances on this canvas
            const existingChart = Chart.getChart(canvas);
            
            if (!lineChart || !existingChart) {
                if (existingChart) existingChart.destroy();

                // Construct datasets
                const datasets = modes.map(mode => ({
                    label: mode,
                    data: labels.map(() => Math.random() * 60), 
                    ...themeStyle(mode, ctx)
                }));

                lineChart = new Chart(ctx, {
                    type: "line",
                    data: { labels, datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            x: { 
                                grid: { color: "#1e293b", drawBorder: false },
                                ticks: { color: "#64748b", font: { family: "'JetBrains Mono'" } }
                            },
                            y: { 
                                beginAtZero: true, 
                                grid: { color: "#1e293b", drawBorder: false },
                                ticks: { color: "#64748b", font: { family: "'JetBrains Mono'" } }
                            }
                        },
                        plugins: {
                            legend: { 
                                labels: { 
                                    color: "#cbd5e1", 
                                    font: { family: "'JetBrains Mono'" },
                                    boxWidth: 10
                                } 
                            }
                        }
                    }
                });
            } else {
                // Update logic could go here, but for demo we just keep it simple
                // lineChart.data.datasets = ...
                lineChart.update('none'); 
            }
        }

        // --- CLOCK ---
        setInterval(() => {
            const clockEl = document.getElementById("clock");
            if(clockEl) {
                const now = new Date();
                clockEl.innerText = now.toLocaleTimeString('en-US', {hour12: false});
            }
        }, 1000);

        // --- MOCK DATA GENERATOR ---
        function getMockData(endpoint) {
            if (endpoint === "/api/stats/day") {
                return {
                    "coding": 240,
                    "browsing": 120,
                    "chatting": 45,
                    "music": 60,
                    "idle": 30
                };
            }
            if (endpoint === "/api/latest") {
                const apps = ["Visual Studio Code", "Chrome", "Discord", "Spotify", "Terminal"];
                const modes = ["coding", "browsing", "chatting", "music", "coding"];
                const titles = ["ui.js - SelfObserver", "Stack Overflow - Python Flask", "#general", "Deep Focus Playlist", "npm install"];
                
                let events = [];
                for(let i=0; i<15; i++) {
                    const r = Math.floor(Math.random() * 5);
                    events.push({
                        ts: new Date(Date.now() - i * 60000).toISOString().replace('T', ' ').substring(0, 19),
                        exe: apps[r],
                        mode: modes[r],
                        confidence: 0.85 + (Math.random() * 0.14),
                        title: titles[r]
                    });
                }
                return events;
            }
        }

        // --- INIT ---
        window.addEventListener('load', () => {
            updateLogs();
            updatePie();
            updateLine();
            
            setInterval(updateLogs, 2000);
            setInterval(updatePie, 5000);
            setInterval(updateLine, 3000);
        });

    </script>
</body>
</html>
